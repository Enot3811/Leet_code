"""Кафе.

Около Петиного университета недавно открылось новое кафе, в котором действует
следующая система скидок: при каждой покупке более чем на 100 рублей покупатель
получает купон, дающий право на один бесплатный обед
(при покупке на сумму 100 рублей и меньше такой купон покупатель не получает).

Однажды Пете на глаза попался прейскурант на ближайшие N дней. Внимательно его
изучив, он решил, что будет обедать в этом кафе все N дней, причем каждый день
он будет покупать в кафе ровно один обед. Однако стипендия у Пети небольшая, и
поэтому он хочет по максимуму использовать предоставляемую систему скидок так,
чтобы его суммарные затраты были минимальны. Требуется найти минимально
возможную суммарную стоимость обедов и номера дней, в которые Пете следует
воспользоваться купонами.

Формат ввода:
В первой строке входного файла записано целое число N (0 ≤ N ≤ 100).
В каждой из последующих N строк записано одно целое число, обозначающее
стоимость обеда в рублях на соответствующий день.
Стоимость — неотрицательное целое число, не превосходящее 300.

Формат вывода:
В первой строке выдайте минимальную возможную суммарную стоимость обедов.
Во второй строке выдайте два числа K1 и K2 — количество купонов, которые
останутся неиспользованными у Пети после этих N дней и количество
использованных им купонов соответственно.

В последующих K2 строках выдайте в возрастающем порядке номера дней, когда Пете
следует воспользоваться купонами. Если существует несколько решений с
минимальной суммарной стоимостью, то выдайте то из них, в котором значение K1
максимально (на случай, если Петя когда-нибудь ещё решит заглянуть в это кафе).
Если таких решений несколько, выведите любое из них.
"""


def main(input_days):
    """
    Для чтения входных данных необходимо получить их
    из стандартного потока ввода (sys.stdin).
    Данные во входном потоке соответствуют описанному
    в условии формату. Обычно входные данные состоят
    из нескольких строк.
    Можно использовать несколько методов:
    * input() -- читает одну строку из потока без символа
    перевода строки;
    * sys.stdin.readline() -- читает одну строку из потока,
    сохраняя символ перевода строки в конце;
    * sys.stdin.readlines() -- вернет список (list) строк,
    сохраняя символ перевода строки в конце каждой из них.
    Чтобы прочитать из строки стандартного потока:
    * число -- int(input()) # в строке должно быть одно число
    * строку -- input()
    * массив чисел -- map(int, input().split())
    * последовательность слов -- input().split()
    Чтобы вывести результат в стандартный поток вывода (sys.stdout),
    можно использовать функцию print() или sys.stdout.write().
    Возможное решение задачи "Вычислите сумму чисел в строке":
    print(sum(map(int, input().split())))
    """
    # n = int(input())
    # input_days = [int(input()) for _ in range(n)]
    # if n == 0:
    #     print(0)
    #     print(0, 0)
    #     return
    results_table = [{} for _ in range(len(input_days))]
    # [
    #     с чем пришли: что вернула рекурсия с таким input
    #     {(cost, num_coupons): cost+, num_coupons+}
    # ]
    result = solve_subtask(days=input_days, day_idx=0, num_coupons=0,
                           coupon_days=[], whole_cost=0,
                           results_table=results_table)
    print(result[0])
    print(result[1], len(result[2]))
    for day in result[2]:
        print(day)


def solve_subtask(
    days, day_idx, num_coupons, coupon_days, whole_cost, results_table
):
    # Если мы дошли до конца
    if day_idx == len(days):
        # То возвращаемся
        return (whole_cost, num_coupons, coupon_days)

    # Если для текущего дня уже есть решение
    if (whole_cost, num_coupons) in results_table[day_idx]:
        # То другого мы ничего не найдём
        return results_table[day_idx][(whole_cost, num_coupons)]

    lunch_cost = days[day_idx]
    day_results = []

    # Если стоимость больше 100
    if lunch_cost > 100:
        # То получаем купон
        day_results.append(
            solve_subtask(days, day_idx + 1, num_coupons + 1, coupon_days,
                          whole_cost + lunch_cost, results_table))

        # Или можем потратить купон
        if num_coupons > 0:
            day_results.append(
                solve_subtask(days, day_idx + 1, num_coupons - 1,
                              coupon_days + [day_idx + 1], whole_cost,
                              results_table))

    # Если стоимость меньше 100
    else:
        # то купон не получаем
        day_results.append(
            solve_subtask(days, day_idx + 1, num_coupons, coupon_days,
                          whole_cost + lunch_cost, results_table))

        # Или можем потратить купон
        if num_coupons > 0:
            day_results.append(
                solve_subtask(days, day_idx + 1, num_coupons - 1,
                              coupon_days + [day_idx + 1], whole_cost,
                              results_table))
            
    # По итогу у нас получаются какие-то результаты для текущего инпута
    # в зависимости от производимых действий
    # Возьмём вариант с минимально потраченными средствами
    # и максимальным количеством купонов
    result = min(day_results)
    results_table[day_idx][(whole_cost, num_coupons)] = result
    return result


if __name__ == '__main__':
    test_cases = [
        [10, 35, 101, 59, 60, 105, 44],
        [10, 35, 40, 101, 59, 63],
    ]
    for test_case in test_cases:
        main(test_case)
        print()

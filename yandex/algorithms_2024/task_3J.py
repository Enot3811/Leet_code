"""J. Кровать из стульев

https://contest.yandex.ru/contest/66794/problems/J/

Есть набор стульев, каждый из которых представлен числами
h_i - высота стула и w_i - ширина стула.
Есть человек, высота которого равна H.

Необходимо соорудить кровать из стульев, чтобы человек мог на ней поместиться.
При этом соседние стулья в этой кровати должны иметь как можно меньшую разницу высоты.
Неудобством кровати является максимальный перепад высоты между соседними стульями.
Неудобство кровати из одного стула будет равна 0.

Цель задачи - найти наименьшую возможную неудобность кровати.

Формат ввода:
n и H - количество стульев и высота человека.
Массив h - высоты стульев.
Массив w - ширины стульев.

Формат вывода:
Одно число - наименьшая возможная неудобность кровати.

Пример 1
Ввод
4 7
1 4 1 2
1 4 2 3
Вывод
2
Пояснение:
Можно соорудить кровать из стульев 2 и 4. Их ширина даст 7,
а разница высоты между ними 2.
Другие варианты не дадут меньшую неудобность.

Пример 2
Ввод
5 6
1 3 5 4 2
5 4 3 2 1
Вывод
1
Пояснение:
Можно соорудить кровать из стульев 1 и 5, или 2,4,3. Они обе дадут неудобность 1.
Стоит обратить внимание на второй вариант. В нём важен порядок стульев.
Хоть ширины стульев 2 и 3 должно хватить, но если вставить между 4, то дискомфорт будет
меньше.
"""

# Размышления
# Задача похожа на плавающее окно с двумя указателями.
# Если отсортировать стулья по высоте, то мы получим минимальную возможное неудобство
# между соседними стульями.
# И так можно расширять окно, пока ширина не станет достаточной,
# а затем уменьшать и двигать его для поиска других вариантов.
# Самое заковыристое здесь это менеджмент стека.
# Нам нужно не просто запоминать все разности высот стульев и вытаскивать их при
# удалении стульев из окна, а сохранять именно максимальные разницы.
# То есть, например [1,2,5,7], [1,1,1,1] при H = 3.
# Сначала мы добавим 2 - 1 = 1, это максимум текущего окна.
# Затем 5 - 2 = 3. И здесь нам нужно выкинуть прошлый 1 из стека, так как он уже
# не описывает текущее окно.
# И при удалении нулевого стула, мы из стека ничего не удалим, так новый максимум всё ещё
# в окне, а старое меньшее значение уже ни на что не повлияет.
# В итоге получится так, что максимум текущего окна всегда будет лежать на самом дне.
# Следующие потенциальный максимумы выше.
# Чтобы потом понимать, когда удалять элемент из стека, нужно ещё сохранить индексы.

from collections import deque

def bed_from_chairs(n: int, H: int, h: list[int], w: list[int]) -> int:
    # Объединим два массива и отсортируем по высоте стульев
    chairs = [(h_i, w_i) for h_i, w_i in zip(h, w)]
    chairs.sort(key=lambda x: x[0])

    left = 0
    right = 0
    curr_w = 0
    # Стек, который будет хранить максимальные перепады высот.
    # Когда мы будем сужать окно, поможет актуализировать новый дискомфорт
    h_diffs = deque()
    ans = float("inf")
    while right < n:
        # Добавляем ширину стула
        curr_w += chairs[right][1]
        # Запоминаем дискомфорт, который он делает с предыдущим (если предыдущий есть)
        if left != right:
            curr_diff = chairs[right][0] - chairs[right - 1][0]
            # Больший дискомфорт вытесняет меньший,
            # так как меньший уже никак не повлияет на ответ.
            # Но если текущий меньше прошлого, он всё ещё сможет стать большим потом.
            while len(h_diffs) > 0 and h_diffs[-1][0] <= curr_diff:
                h_diffs.pop()
            # r - 1, так как удалять будем слева, а добавляем сейчас справа
            h_diffs.append((curr_diff, right - 1))

        # Собрали нужную длину, сужаем окно
        while curr_w >= H and left <= right:

            # Максимум для окна на самом дне
            if len(h_diffs) > 0:
                ans = min(ans, h_diffs[0][0])
            # А если стек пустой, то мы обошлись одним стулом,
            # и это лучший случай
            else:
                return 0

            curr_w -= chairs[left][1]
            # Выкидываем стул, который делал максимальный дискомфорт
            if left == h_diffs[0][1]:
                h_diffs.popleft()
            left += 1
        right += 1
    return ans

n, H = map(int, input().split())
h = list(map(int, input().split()))
w = list(map(int, input().split()))
print(bed_from_chairs(n, H, h, w))

cases = [
    ((4, 7, [1, 4, 1, 2], [1, 4, 2, 3]), 2),
    ((5, 6, [1, 3, 5, 4, 2], [5, 4, 3, 2, 1]), 1),
    ((5, 3, [1,2,5,7,8], [1,1,1,1,1]), 2),
    ((1, 5, [5], [5]), 0),
    ((7, 3, [1,2,5,7,8,10,15], [1,1,1,1,1,3,1]), 0),
    ((7, 3, [1,2,5,7,9,10,11], [1,1,1,1,1,1,1]), 1),
    ((9, 3, [1,5,9,11,13,13,14,16,18], [1,1,1,1,1,1,1,1,1]), 1),
    ((4, 4, [1,5,6,8], [5,2,3,4]), 0),
    ((15, 10, [1,5,6,8,10,12,13,16,18,19,20,21,25,28,30], [4,3,5,7,1,2,5,3,2,7,8,3,5,1,2]), 1),
    ((3, 3, [3,5,6], [1,1,1]), 2),
    ((3, 3, [3,3,3], [1,1,1]), 0),
    ((7, 3, [1,2,3,3,3,4,5], [1,1,1,1,1,1,1]), 0),
]
for inp, ans in cases:
    res = bed_from_chairs(*inp)
    print(inp, res, ans)

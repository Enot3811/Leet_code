"""J. Исследование улик

https://contest.yandex.ru/contest/66793/problems/J/#30404/2024_10_27/moUrvVzWIu

Есть улики, вес которых в массиве a.
Изучение улик происходит справа-налево.
При изучении можно переходить от более весомой улики к менее или равной, но не к более.
Если следующая более весомая, то изучение оканчивается.
Пройтись по одинаковой весомости можно лишь k раз за исследование. При достижении k
одновесомых проходов изучение оканчивается.

Даётся x массив с индексами старта для изучения. Необходимо для каждого xi указать
индекс окончания.
"""
# Рассуждения
# Мы можем заранее посчитать стоп индексы для всех улик.
# В целом легко, но много мороки с индексами из-за хождения справа-налево и возможности
# установить k = 0. Приходится смотреть наперёд, хотя я привык смотреть на текущий

def detective(a: list[int], k: int, x: list[int]) -> list[int]:
    # Сделаем преподсчёт для каждой улики, где мы остановимся, начиная с неё
    stop_indexes = [0] * len(a)
    left = len(a) - 1
    right = len(a) - 1
    cur_k = 0
    while left > 0:
        # Если следующая улика больше, то сдвигаем правый сразу на неё
        # и устанавливаем конечный индекс для всех до неё на неё же
        if a[left - 1] > a[left]:
            for i in range(left, right + 1):
                stop_indexes[i] = left
            right = left - 1  # вот здесь не интуитивно из-за того, что смотрим наперёд
            # left сровняется с right в конце итерации
            cur_k = 0
        # Если следующая равна текущей, то возможно нам надо будет подвигать правый,
        # чтобы установить конечные индексы
        elif a[left - 1] == a[left]:
            cur_k += 1

            while cur_k > k and left <= right:
                stop_indexes[right] = left
                if a[right] == a[right - 1]:
                    cur_k -= 1
                right -= 1
        left -= 1
    
    # Теперь, когда предпсчёт сделан, просто берём интересующие индексы
    return [stop_indexes[i - 1] + 1 for i in x]


_ = input()
a = list(map(int, input().split()))
m, k = tuple(map(int, input().split()))
x = list(map(int, input().split()))
print(*detective(a, k, x))

examples = [
    ((
        6,
        [3, 3, 3, 4, 4, 5],
        4, 2,
        [3, 4, 5, 6]
    ), [1, 1, 2, 2]),
    ((
        7,
        [1, 5, 7, 2, 10, 10, 6],
        7, 0,
        [1, 2, 3, 4, 5, 6, 7]
    ), [1, 1, 1, 4, 4, 6, 7])
]

for inp, ans in examples:
    _, a, _, k, x = inp
    res = detective(a, k, x)
    print(inp, res, ans)


"""C. Минимум на отрезке.

Есть отрезок с числами. По нему проходят окном длинны k.
Необходимо вычислить минимумы для всех окон
"""


from collections import deque


# Рассуждения
# Будем формировать очередь потенциальных минимумов
# Добавляем каждое числов в очередь, ведь оно может стать минимумом
# Но при добавлении смотрим, если ранее стоит число, которое больше текущего,
# то выкидываем его
# Когда захотим взять минимум для текущего окна, будем тянуть слева из очереди
# Если элемент вписывается в окно по индексу, то ок, если нет, то выкидываем его
# и берём следующий
# Такое решение даст линейную сложность
# Решение же в лоб будет O(n*k). И хоть n и зависит от значения k как len(a) - k + 1,
# но ближе к значению n = len(a) / 2 будет наблюдаться квадратичная сложность

def min_of_windows(arr: list[int], k: int) -> list[int]:
    stack = deque()
    answer = [0] * (len(arr) - k + 1)
    for i, n in enumerate(arr):
        # Выбрасываем элементы из стека, пока они больше текущего
        # ведь они уже точно не будут минимумами
        while len(stack) > 0 and stack[-1][0] >= n:
            stack.pop()
        
        # Всегда добавляем текущий элемент
        stack.append((n, i))

        # Начинаем считать значения для окон, когда первое начинает помещаться
        if i >= k - 1:
            ans_idx = i - k + 1

            # Выкидываем минимумы, которые уже не вписываются в наше окно
            while stack[0][1] < ans_idx:
                    stack.popleft()

            answer[ans_idx] = stack[0][0]

    return answer


_, k = tuple(map(int, input().split()))
arr = list(map(int, input().split()))
print(*min_of_windows(arr, k), sep='\n')


examples = [
    ((7, 3, [1, 3, 2, 4, 5, 3, 1]), [1, 2, 2, 3, 1]),
]

for inp, ans in examples:
    _, k, arr = inp
    res = min_of_windows(arr, k)
    print(arr, res, ans)

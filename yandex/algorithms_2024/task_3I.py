"""I. Автоматизированный склад

https://contest.yandex.ru/contest/66794/problems/I/

Есть перекрёсток, по которому движутся тележки.
Тележки могут двигаться только прямо.
Стороны перекрёстка обозначены номерами от 1 до 4 по часовой стрелке.
У перекрёстка есть 2 главных и 2 второстепенных направления.
Необходимо определить порядок, по которому тележки должны пересечь перекрёсток,
руководствуясь правилами ПДД.

Входные данные:
Первая строка - число n, количество тележек
Вторая строка - числа a и b, номера главных направлений перекрёстка
Следующий n строк - описание тележек в виде двух чисел di и ti,
направление откуда выезжает тележка и время её приезда.

Пример 1:
Ввод
4
1 3
1 1
3 1
2 1
2 2
Вывод
1
1
2
3
Объяснение:
В первый момент приезжает 3 тележки с направлениями 1, 2 и 3.
Сначала должны проехать главные: 1 и 3. Они не мешают друг-другу при проезде, поэтому
могут проехать одновременно.
Во второй момент подъезжает ещё одна тележка с направлением 2. Они поедут по очереди
в следующие 2 такта.

Пример 2:
Ввод
4
1 2
1 1
2 1
3 1
4 1
Вывод
1
2
3
4

Все тележки приезжают одновременно.
Сначала проедут главные. Тележка из направления 1 блокирует тележку из направления 2,
так как она справа. Направление 1 проедет первым.
Затем направление 2, так как она единственная главная.
Затем 3, так как 4 блокируется ею. И потом 4.
"""

# Размышления
# У задачи нет какой-то подковырки, она решается прямо в лоб,
# но вот структурировать решение очень сложно.
# Единственный фокус лишь в том, чтобы отсортировать тележки по времени прибытия.
# А далее нужно постараться разбить задачу на части, и постепенно их воспроизводить.
# Хоть это не очень эффективно, но для простоты можно сделать цикл по тактам времени.
# На каждом такте проверять 4 направления, хочет ли кто-то поехать из них.
# Если хочет, то проверить может ли.
# Когда может?
# - Главная и нет справа главной, которая тоже хочет
# - Второстепенная и нет главной или правой, которые хотят ехать
# В итоге это не противоречит положению, что две тележки навстречу друг-другу могут
# проехать одновременно.

from collections import deque

def crossroad(n: int, a: int, b: int, carts: list[list[int, int]]) -> list[int]:
    def is_main(x: int) -> bool:
        """Главный ли x."""
        return x == a or x == b

    def right(x: int) -> int:
        """Кто справа от x."""
        return (x - 1) % 4

    def can_go(x: int) -> bool:
        """Может ли поехать направление x."""
        return len(qs[x]) > 0 and time >= qs[x][0][0]

    # Переводим в 0 нумерацию
    a -= 1
    b -= 1
    # Отсортируем тележки по времени их прибытия
    for i in range(len(carts)):
        carts[i].append(i)
    carts.sort(key=lambda x: x[1])
    # Раскидаем тележки по их направлениям
    qs = [deque() for _ in range(4)]
    for d, t, i in carts:
        # Тоже 0 нумерация
        qs[d - 1].append((t, i))

    # Цикл пока не проедут все тележки
    ans = [0] * n
    time = 1
    while n > 0:

        # Каждый такт времени проверяем каждое направление, может ли оно поехать
        moves = [False] * 4
        for dir in range(4):
            if can_go(dir):
                # Главная, но справа тоже главная, и она может поехать
                if is_main(dir) and is_main(right(dir)) and can_go(right(dir)):
                    continue
                # Второстепенная, и при этом либо главная, либо правая может поехать
                if not is_main(dir) and (can_go(a) or can_go(b) or can_go(right(dir))):
                    continue
                # В противных же случаях ничего не мешает поехать
                moves[dir] = True
        
        # Отправляем тех, кто может поехать
        for dir in range(4):
            if moves[dir]:
                _, i = qs[dir].popleft()
                ans[i] = time
                n -= 1
        time += 1
    return ans

n = int(input())
a, b = map(int, input().split())
carts = [list(map(int, input().split())) for _ in range(n)]
print(*crossroad(n, a, b, carts), sep='\n')

cases = [
    ((4,1,2,[[1,1],[2,1],[3,1],[4,1]]),[1,2,3,4]),
    ((4,1,3,[[1,1],[3,1],[2,1],[2,2]]),[1,1,2,3])
]
for inp, ans in cases:
    res = crossroad(*inp)
    print(inp, res, ans)

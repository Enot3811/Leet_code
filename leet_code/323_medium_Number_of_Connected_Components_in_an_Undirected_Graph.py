"""323. Number of Connected Components in an Undirected Graph

Premium lock.
https://neetcode.io/problems/count-connected-components/question

There is an undirected graph with n nodes.
There is also an edges array, where edges[i] = [a, b] means that there is an edge
between node a and node b in the graph.

The nodes are numbered from 0 to n - 1.

Return the total number of connected components in that graph.

Example 1:
Input:
n=3
edges=[[0,1], [0,2]]
Output:
1

Example 2:
Input:
n=6
edges=[[0,1], [1,2], [2,3], [4,5]]
Output:
2

Constraints:
1 <= n <= 100
0 <= edges.length <= n * (n - 1) / 2
"""

# Размышления
# Проверка связности графа часто встречается в задачи на графы, а здесь она сама и
# является задачей.
# Как всегда для удобства создадим матрицу (список) связности, по которому будет
# удобно ориентироваться в графе.
# Так как граф ненаправленный, то связи должны идти в обе стороны.
# То есть при добавлении ребра [0,1] нужно добавить и ребро [1,0] тоже.
# Далее мы берём какую-либо ноду и пытаемся пройти по всем нодам через её связи.
# Для этого как раз и добавлялись двойные связи, чтобы было не принципиально с какой
# ноды начинать, и всё равно иметь возможность пройти по всем.
# Если граф полносвязный, то мы посетим все ноды.
# Если нет, то какие-то останутся не посещёнными.
# В итоге мы запускаем проход по нодам до тех пор, пока не посетим все ноды.
# Сколько запусков понадобится, столько и есть компонент связности в графе.

from typing import List
from collections import deque

class Solution:
    def countComponents(self, n: int, edges: List[List[int]]) -> int:
        adj = [[] for _ in range(n)]
        for a, b in edges:
            adj[a].append(b)
            adj[b].append(a)
        
        not_visited = set(range(n))
        stack = deque()
        ans = 0
        while len(not_visited) != 0:
            ans += 1
            stack.append(not_visited.pop())
            while len(stack) != 0:
                node = stack.popleft()
                for neighbor in adj[node]:
                    if neighbor in not_visited:
                        not_visited.remove(neighbor)
                        stack.append(neighbor)
        return ans

# Альтернативный и более эффективный вариант - union find алгоритм.
# Можно использовать когда нужно тем или иным образом объединять какие-то множества,
# или проверять ненаправленный граф на наличие циклов.
# Основная идея алгоритма в том, что есть какие-то множества.
# У каждого из них есть корень, главный родитель.
# Например: [[0,1], [1,2]]. Связываем 0 и 1. Теперь у 0 родитель 0, у 1 родитель 0.
# Связываем 1 и 2. У 1 родитель 0, у 2 становится 0.
# В итоге они связаны и у них общий родитель.
# Теперь про оптимизацию.
# Когда нам нужно перезаписать родителя,
# то приходится проходить по все элементам множества, что очень долго.
# Как выход используют ленивое переприсваивание родителя.
# То есть например, у нас была структура 1->3 и 2->3.
# Оказывается, что мы теперь хотим присоединить это дерево к другому,
# то есть сделать 3->4.
# Мы так и оставим 1->3 и 2->3, но в следующий раз, когда нас спросят про родителя,
# например, если мы получили edge [5,1], мы увидим 1->3->4 и просто переприсвоим 1->4.
# То есть ноды, к которым не обращаемся, могут хранить устаревший корень, но он так или
# иначе приведёт нас к текущему настоящему.
# При этом если бы было 1->2->3->4 у нас бы удалось сделать 1->4, 2->4 и 3->4,
# но в большинстве случаев ноды сразу хранят указатель на истинный корень.
# И вторая оптимизация: всегда присоединяем меньшее дерево к большему.
# Для этого используется либо ранг (высота дерева), либо size.
# Логично, что в меньшем дереве более выгодно будет потом переприсваивать корень.
# Ранг есть у каждой ноды, и показывает высоту дерева с корнем в этой ноде.
# Ранг увеличивается только тогда, когда к дереву присоединяют ветвь высотой
# с само дерево. То есть получается высота ветви + корень = n + 1.
# В остальных же случаях, если ранг присоединяемого меньше, то в самом дереве уже была
# ветвь длиннее, значит ранг не меняется.
# Разберём пример:
# [0,1],[2,3],[1,2]. Получится сначала 0->1, 2->3 корни 1 и 3
# Затем делаем 1->2, но 2 вернёт 3, то есть 1->3, 2->3, но 0->1, так как 0 не затронули.
# Затем, допустим, пусть будет [0,4]. Тогда при find(0) станет 0->3,
# и затем при union(0, 4) станет 4->3.

class Solution:
    def countComponents(self, n: int, edges: List[List[int]]) -> int:
        parents = list(range(n))
        rank = [1,] * n
        ans = n  # Изначально считаем, что каждая нода сама по себе

        def find(i: int) -> int:
            """Поиск родителя для ноды i.

            Если нода - корень, то она сама себе родитель, возвращаем её же.
            Если же нет, то у нас может получается цепочка вида 1->2->3->4.
            Так как идти к корню таким образом каждый раз долго,
            мы будем перенаправлять связи.
            1->2->3->4 превратив в 1->4, 2->4 и 3->4
            """
            # Если не корень
            if parents[i] != i:
                # Мы не просто ищем корень, а перезаписываем текущего родителя этим корнем
                parents[i] = find(parents[i])
            return parents[i]

        def union(first: int, second: int) -> bool:
            """Проверка и объединение множеств.

            Если у first и second оказывается один и тот же корень,
            то они в одном множестве.
            Если же нет, то присоединяем дерево с меньшим рангом к большему.
            Если у них одинаковый ранг, то при слитии ранг увеличится на 1.
            (Присоединяем ветку размером n к корню, и вместе с корнем теперь n + 1).
            """
            first_root = find(first)
            second_root = find(second)
            if first_root != second_root:
                if rank[first_root] > rank[second_root]:
                    parents[second_root] = first_root
                elif rank[first_root] < rank[second_root]:
                    parents[first_root] = second_root
                else:
                    parents[second_root] = first_root
                    rank[first_root] += 1
                return True
            return False

        for first, second in edges:
            if union(first, second):
                ans -= 1
        return ans

cases = [
    ((3, [[0,1], [0,2]]), 1),
    ((6, [[0,1], [1,2], [2,3], [4,5]]), 2),
    ((8, [[0,1],[0,2],[3,0],[3,1],[5,4],[4,6]]), 3),
    ((6, [0,1],[1,2],[2,3],[5,4],[4,3]), 1)
]
sol = Solution()
for inp, ans in cases:
    res = sol.countComponents(*inp)
    print(inp, res, ans)

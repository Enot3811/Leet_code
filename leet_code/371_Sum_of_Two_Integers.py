"""371. Sum of Two Integers

https://leetcode.com/problems/sum-of-two-integers/

Given two integers a and b,
return the sum of the two integers without using the operators + and -.

Example 1:
Input: a = 1, b = 2
Output: 3

Example 2:
Input: a = 2, b = 3
Output: 5

Constraints:
-1000 <= a, b <= 1000
"""

# Размышления
# Нужно сымитировать операцию сложения с помощью бинарных операций
# 1) xor: 1 ^ 0 = 1, 0 ^ 0 = 0, 1 ^ 1 = 0
# Но не хватает +1 дле следующего разряда, если 1 + 1.
# 2) and: 1 & 1 = 1. То есть можем определять так разряды, где 1 идёт в следующий
# Но как переместить его в следующий?
# 3) <<: 01 << 1 = 10. Сдвиг поможет как раз свдинуть эти разряды на 1 вперёд,
# и затем нам нужно сложить xor маску и and маску, а это уже рекурсивная или цикличная
# задача, ведь xor и and тоже могут иметь 1 в одних и тех же разрядах.
# Пример:
# 11 = 1011
# 9 = 1001
# 1011 ^ 1001 = 0010
# 1011 & 1001 = 1001 << 1 = 10010
# 10 ^ 10010 = 10000
# 10 & 10010 << 1 = 100
# 10000 ^ 100 = 10100 = 20
# 10000 & 100 = 00000
# Получается, делаем до тех пор, пока & операция не даст 0,
# то есть не будет больше разрядов для переноса
# Что касательно отрицательных чисел?
# Отрицательный числа представлены "дополнительным кодом".
# То есть старший бит - знаковый, а все остальные биты - инверсия + 1
# Например:
# -1 = 111...1111
# -5 = 111...1011
# -1 + -5 = 111...1010 = -6
# При этом в моменты, когда число должно поменять знак, помогает переполнение
# -1 = 111...1111
# 2 = 10
# 111...1111 + 10 = 000...0001 один разряд пошёл по всем налево
# и в итоге ушёл в переполнение.
# В python всё то же самое, но при этом числа не ограничены 32 битами.
# Потом нам необходимо вручную ограничить числа and маской.


class Solution:
    def getSum(self, a: int, b: int) -> int:
        # Маска для ограничения числа 32 битами
        mask = 0xFFFFFFFF

        while b != 0:
            c = (a & b) << 1 & mask
            a = (a ^ b) & mask  # Маска, чтобы урезать бесконечные единицы отрицательных
            b = c
        
        # После цикла a содержит результат в виде 32-битного беззнакового числа.
        # Если число отрицательное (старший 31-й бит равен 1),
        # Python будет считать его большим положительным числом.
        # Нам нужно преобразовать его обратно в "питоновский" отрицательный int.
        
        # 0x7FFFFFFF — это максимальное положительное 32-битное число (2147483647).
        if a > 0x7FFFFFFF:
            # Преобразуем обратно в отрицательное число
            a = ~(a ^ mask)
            
        return a


cases = [
    # ((3, 4), 7),
    # ((0, 1), 1),
    # ((0, 0), 0),
    # ((135, 92), 227),
    ((-5, 9), 4),
    ((-5, -9), -14)
]
sol = Solution()
for inp, ans in cases:
    res = sol.getSum(*inp)
    print(inp, res, ans)
